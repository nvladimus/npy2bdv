<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>npy2bdv.npy2bdv API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>npy2bdv.npy2bdv</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Fast writing of numpy arrays to HDF5 format compatible with Fiji/BigDataViewer and BigStitcher
# Author: Nikita Vladimirov
# License: GPL-3.0
import os
import h5py
import numpy as np
from xml.etree import ElementTree as ET
import skimage.transform
import shutil


class BdvWriter:
    __version__ = &#34;2020.10&#34;

    def __init__(self, filename,
                 subsamp=((1, 1, 1),),
                 blockdim=((4, 256, 256),),
                 compression=None,
                 nilluminations=1, nchannels=1, ntiles=1, nangles=1,
                 overwrite=False):
        &#34;&#34;&#34;Class for writing multiple numpy 3d-arrays into BigDataViewer/BigStitcher HDF5 file.

        Parameters:
        -----------
            filename: string
                File name (full path).
            subsamp: tuple of tuples
                Subsampling levels in (z,y,x) order. Integers &gt;= 1, default value ((1, 1, 1),) for no subsampling.
            blockdim: tuple of tuples
                Block size for h5 storage, in pixels, in (z,y,x) order. Default ((4,256,256),), see notes.
            compression: None or str
                (None, &#39;gzip&#39;, &#39;lzf&#39;), HDF5 compression method. Default is None for high-speed writing.
            nilluminations: int
            nchannels: int
            ntiles: int
            nangles: int
                Number of view attributes, &gt;=1.
            overwrite: boolean
                If True, overwrite existing file. Default False.

        .. note::
        ------
        Input stacks and output files are assumed uint16 type.

        The h5 recommended block (chunk) size should be between 10 KB and 1 MB, larger for large arrays.
        For example, block dimensions (4,256,256)px gives ~0.5MB block size for type int16 (2 bytes) and writes very fast.
        Block size can be larger than stack dimension.
        &#34;&#34;&#34;
        assert nilluminations &gt;= 1, &#34;Total number of illuminations must be at least 1.&#34;
        assert nchannels &gt;= 1, &#34;Total number of channels must be at least 1.&#34;
        assert ntiles &gt;= 1, &#34;Total number of tiles must be at least 1.&#34;
        assert nangles &gt;= 1, &#34;Total number of angles must be at least 1.&#34;
        assert compression in (None, &#39;gzip&#39;, &#39;lzf&#39;), &#39;Unknown compression type&#39;
        assert all([isinstance(element, int) for tupl in subsamp for element in
                    tupl]), &#39;subsamp values should be integers &gt;= 1.&#39;
        if len(blockdim) &lt; len(subsamp):
            print(f&#34;INFO: blockdim levels ({len(blockdim)}) &lt; subsamp levels ({len(subsamp)}):&#34;
                  f&#34; First-level block size {blockdim[0]} will be used for all levels&#34;)
        self._fmt = &#39;t{:05d}/s{:02d}/{}&#39;
        self.nsetups = nilluminations * nchannels * ntiles * nangles
        self.nilluminations = nilluminations
        self.nchannels = nchannels
        self.ntiles = ntiles
        self.nangles = nangles
        self.subsamp = np.asarray(subsamp)
        self.nlevels = len(subsamp)
        self.chunks = self._compute_chunk_size(blockdim)
        self.stack_shapes = {}
        self.affine_matrices = {}
        self.affine_names = {}
        self.calibrations = {}
        self.voxel_size_xyz = {}
        self.voxel_units = {}
        self.exposure_time = {}
        self.exposure_units = {}
        self.compression = compression
        self.filename = filename
        if os.path.exists(self.filename):
            if overwrite:
                os.remove(self.filename)
                print(&#34;Warning: H5 file already exists, overwriting.&#34;)
            else:
                raise FileExistsError(f&#34;File {self.filename} already exists.&#34;)
        self.file_object = h5py.File(filename, &#39;a&#39;)
        self._write_setups_header()
        self.virtual_stacks = False
        self.setup_id_present = [[False] * self.nsetups]

    def _write_setups_header(self):
        &#34;&#34;&#34;Write resolutions and subdivisions for all setups into h5 file.&#34;&#34;&#34;
        for isetup in range(self.nsetups):
            group_name = &#39;s{:02d}&#39;.format(isetup)
            if group_name in self.file_object:
                del self.file_object[group_name]
            grp = self.file_object.create_group(group_name)
            data_subsamp = np.flip(self.subsamp, 1)
            data_chunks = np.flip(self.chunks, 1)
            grp.create_dataset(&#39;resolutions&#39;, data=data_subsamp, dtype=&#39;&lt;f8&#39;)
            grp.create_dataset(&#39;subdivisions&#39;, data=data_chunks, dtype=&#39;&lt;i4&#39;)

    def append_plane(self, plane, z, time=0, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Append a plane to a virtual stack. Requires stack initialization by calling e.g.
        `append_view(stack=None, virtual_stack_dim=(1000,2048,2048))` beforehand.
        
        Parameters:
        -----------
            plane: array_like
                A 2d numpy array of (y,x) pixel values.
            z: int
                Plane z-position in the virtual stack.
            time: int
                Time index of the view, &gt;=0.
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;=0.
        &#34;&#34;&#34;
        
        assert self.virtual_stacks, &#34;Appending planes requires initialization with virtual stack, &#34; \
                                    &#34;see append_view(stack=None,...)&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._update_setup_id_present(isetup, time)
        assert plane.shape == self.stack_shapes[isetup][1:], &#34;Plane dimensions must match (y,x) size of virtual stack.&#34;
        assert z &lt; self.stack_shapes[isetup][0], &#34;Plane index must be less than virtual stack z-dimension.&#34;
        for ilevel in range(self.nlevels):
            group_name = self._fmt.format(time, isetup, ilevel)
            dataset = self.file_object[group_name][&#34;cells&#34;]
            dataset[z, :, :] = self._subsample_plane(plane, self.subsamp[ilevel]).astype(&#39;int16&#39;)

    def append_substack(self, substack, z_start, y_start=0, x_start=0,
                        time=0, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Append a substack to a virtual stack. Requires stack initialization by calling e.g.
        `append_view(stack=None, virtual_stack_dim=(1000,2048,2048))` beforehand.

        Parameters:
        -----------
            substack: array_like
                A 3d numpy array of (z,y,x) pixel values.
            z_start: int
            y_start: int
            z_start: int
                Offsets (z,y,x) of the substack in the virtual stack.
            time: int
                Time index of the view, &gt;=0.
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;=0.
        &#34;&#34;&#34;

        assert self.virtual_stacks, &#34;Appending substack requires initialization with virtual stack, &#34; \
                                    &#34;see append_view(stack=None,...)&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._update_setup_id_present(isetup, time)
        assert z_start + substack.shape[0] &lt;= self.stack_shapes[isetup][0], \
            f&#34;Substack offset {z_start} + z-dim {substack.shape[0]} &gt; virtual stack z-dim {self.stack_shapes[isetup][0]}.&#34;
        assert y_start + substack.shape[1] &lt;= self.stack_shapes[isetup][1], \
            f&#34;Substack offset {y_start} + y-dim {substack.shape[1]} &gt; virtual stack y-dim {self.stack_shapes[isetup][1]}.&#34;
        assert x_start + substack.shape[2] &lt;= self.stack_shapes[isetup][2], \
            f&#34;Substack offset {x_start} + x-dim {substack.shape[2]} &gt; virtual stack x-dim {self.stack_shapes[isetup][2]}.&#34;
        for ilevel in range(self.nlevels):
            group_name = self._fmt.format(time, isetup, ilevel)
            dataset = self.file_object[group_name][&#34;cells&#34;]
            subdata = self._subsample_stack(substack, self.subsamp[ilevel]).astype(&#39;int16&#39;)
            dataset[z_start : z_start + substack.shape[0],
                    y_start : y_start + substack.shape[1],
                    x_start : x_start + substack.shape[2]] = subdata

    def append_view(self, stack, virtual_stack_dim=None,
                    time=0, illumination=0, channel=0, tile=0, angle=0,
                    m_affine=None, name_affine=&#39;manually defined&#39;,
                    voxel_size_xyz=(1, 1, 1), voxel_units=&#39;px&#39;, calibration=(1, 1, 1),
                    exposure_time=0, exposure_units=&#39;s&#39;):
        &#34;&#34;&#34;
        Write 3-dimensional numpy array (stack) to the h5 file with the specified timepoint `itime` and attributes.
        
        Parameters:
        -----------
            stack: numpy array (uint16) or None
                A 3-dimensional stack of uint16 data in (z,y,x) axis order.
                If None, creates an empty dataset of size huge_stack_dim.
            virtual_stack_dim: None, or tuple of (z,y,x) dimensions, optional.
                Dimensions to allocate a huge stack and fill it later by individual planes or substacks.
            time: int
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            m_affine: a numpy array of shape (3,4), optional.
                Coefficients of affine transformation matrix (m00, m01, ...). The last column is translation in (x,y,z).
            name_affine: str, optional
                Name of the affine transformation.
            voxel_size_xyz: tuple of size 3, optional
                The physical size of voxel, in voxel_units. Default (1, 1, 1).
            voxel_units: str, optional
                Spatial units, default is &#39;px&#39;.
            calibration: tuple of size 3, optional
                The anisotropy factors for (x,y,z) voxel calibration. Default (1, 1, 1).
                Leave it default unless you know how it affects transformations.
            exposure_time: float, optional
                Camera exposure time for this view, default 0.
            exposure_units: str, optional
                Time units for this view, default &#34;s&#34;.
        &#34;&#34;&#34;
        
        assert len(calibration) == 3, &#34;Calibration must be a tuple of 3 elements (x, y, z).&#34;
        assert len(voxel_size_xyz) == 3, &#34;Voxel size must be a tuple of 3 elements (x, y, z).&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._update_setup_id_present(isetup, time)
        if stack is not None:
            assert len(stack.shape) == 3, &#34;Stack should be a 3-dimensional numpy array (z,y,x)&#34;
            self.stack_shapes[isetup] = stack.shape
        else:
            assert len(virtual_stack_dim) == 3, &#34;Stack is virtual, so parameter virtual_stack_dim must be defined.&#34;
            self.stack_shapes[isetup] = virtual_stack_dim
            self.virtual_stacks = True

        for ilevel in range(self.nlevels):
            group_name = self._fmt.format(time, isetup, ilevel)
            if group_name in self.file_object:
                del self.file_object[group_name]
            grp = self.file_object.create_group(group_name)
            if stack is not None:
                subdata = self._subsample_stack(stack, self.subsamp[ilevel]).astype(&#39;int16&#39;)
                grp.create_dataset(&#39;cells&#39;, data=subdata, chunks=self.chunks[ilevel],
                                   maxshape=(None, None, None), compression=self.compression, dtype=&#39;int16&#39;)
            else:  # a virtual stack initialized
                grp.create_dataset(&#39;cells&#39;, chunks=self.chunks[ilevel],
                                   shape=virtual_stack_dim // self.subsamp[ilevel],
                                   compression=self.compression, dtype=&#39;int16&#39;)
        if m_affine is not None:
            self.affine_matrices[isetup] = m_affine.copy()
            self.affine_names[isetup] = name_affine
        self.calibrations[isetup] = calibration
        self.voxel_size_xyz[isetup] = voxel_size_xyz
        self.voxel_units[isetup] = voxel_units
        self.exposure_time[isetup] = exposure_time
        self.exposure_units[isetup] = exposure_units

    def _compute_chunk_size(self, blockdim):
        &#34;&#34;&#34;Populate the size of h5 chunks.
        Use first-level chunk size if there are more subsampling levels than chunk size levels.
        &#34;&#34;&#34;
        chunks = []
        base_level = blockdim[0]
        if len(blockdim) &lt; len(self.subsamp):
            for ilevel in range(len(self.subsamp)):
                chunks.append(base_level)
            chunks_tuple = tuple(chunks)
        else:
            chunks_tuple = blockdim
        return chunks_tuple

    def _subsample_stack(self, stack, subsamp_level):
        &#34;&#34;&#34;Subsampling of 3d stack.
        
        Parameters:
        -----------
            stack, numpy 3d array (z,y,x) of int16
            subsamp_level, array-like with 3 elements, eg (2,4,4) for downsampling z(x2), x and y (x4).
            
        Returns:
        --------
            down-scaled stack, unit16 type.
        &#34;&#34;&#34;
        if all(subsamp_level[:] == 1):
            stack_sub = stack
        else:
            stack_sub = skimage.transform.downscale_local_mean(stack, tuple(subsamp_level)).astype(np.uint16)
        return stack_sub

    def _subsample_plane(self, plane, subsamp_level):
        &#34;&#34;&#34;Subsampling of a 2d plane.
        
        Parameters:
        -----------
            plane: numpy 2d array (y,x) of int16
            subsamp_level: array-like with 3 elements, eg (1,4,4) for downsampling x and y (x4).
            
        Returns:
        --------
            down-scaled plane, unit16 type.
        &#34;&#34;&#34;
        assert subsamp_level[0] == 1, &#34;z-subsampling must be == 1 for virtual stacks.&#34;
        if all(subsamp_level[:] == 1):
            plane_sub = plane
        else:
            plane_sub = skimage.transform.downscale_local_mean(plane, tuple(subsamp_level[1:])).astype(np.uint16)
        return plane_sub

    def write_xml_file(self, ntimes=1,
                       camera_name=&#34;default&#34;,  microscope_name=&#34;default&#34;,
                       microscope_version=&#34;0.0&#34;, user_name=&#34;user&#34;):
        &#34;&#34;&#34;
        Write XML header file for the HDF5 file.

        Parameters:
        -----------
            ntimes: int
                Number of time points
            camera_name: str, optional
                Name of the camera (same for all setups at the moment)
            microscope_name: str, optional
            microscope_version: str, optional
            user_name: str, optional
        &#34;&#34;&#34;
        assert ntimes &gt;= 1, &#34;Total number of time points must be at least 1.&#34;
        root = ET.Element(&#39;SpimData&#39;)
        root.set(&#39;version&#39;, &#39;0.2&#39;)
        bp = ET.SubElement(root, &#39;BasePath&#39;)
        bp.set(&#39;type&#39;, &#39;relative&#39;)
        bp.text = &#39;.&#39;
        # new XML data, added by @nvladimus
        generator = ET.SubElement(root, &#39;generatedBy&#39;)
        library = ET.SubElement(generator, &#39;library&#39;)
        library.set(&#39;version&#39;, self.__version__)
        library.text = &#34;npy2bdv&#34;
        microscope = ET.SubElement(generator, &#39;microscope&#39;)
        ET.SubElement(microscope, &#39;name&#39;).text = microscope_name
        ET.SubElement(microscope, &#39;version&#39;).text = microscope_version
        ET.SubElement(microscope, &#39;user&#39;).text = user_name
        # end of new XML data

        seqdesc = ET.SubElement(root, &#39;SequenceDescription&#39;)
        imgload = ET.SubElement(seqdesc, &#39;ImageLoader&#39;)
        imgload.set(&#39;format&#39;, &#39;bdv.hdf5&#39;)
        el = ET.SubElement(imgload, &#39;hdf5&#39;)
        el.set(&#39;type&#39;, &#39;relative&#39;)
        el.text = os.path.basename(self.filename)
        # write ViewSetups
        viewsets = ET.SubElement(seqdesc, &#39;ViewSetups&#39;)
        for iillumination in range(self.nilluminations):
            for ichannel in range(self.nchannels):
                for itile in range(self.ntiles):
                    for iangle in range(self.nangles):
                        isetup = self._determine_setup_id(iillumination, ichannel, itile, iangle)
                        if any([self.setup_id_present[t][isetup] for t in range(len(self.setup_id_present))]):
                            vs = ET.SubElement(viewsets, &#39;ViewSetup&#39;)
                            ET.SubElement(vs, &#39;id&#39;).text = str(isetup)
                            ET.SubElement(vs, &#39;name&#39;).text = &#39;setup &#39; + str(isetup)
                            nz, ny, nx = tuple(self.stack_shapes[isetup])
                            ET.SubElement(vs, &#39;size&#39;).text = &#39;{} {} {}&#39;.format(nx, ny, nz)
                            vox = ET.SubElement(vs, &#39;voxelSize&#39;)
                            ET.SubElement(vox, &#39;unit&#39;).text = self.voxel_units[isetup]
                            dx, dy, dz = self.voxel_size_xyz[isetup]
                            ET.SubElement(vox, &#39;size&#39;).text = &#39;{} {} {}&#39;.format(dx, dy, dz)
                            # new XML data, added by @nvladimus
                            cam = ET.SubElement(vs, &#39;camera&#39;)
                            ET.SubElement(cam, &#39;name&#39;).text = camera_name
                            ET.SubElement(cam, &#39;exposureTime&#39;).text = &#39;{}&#39;.format(self.exposure_time[isetup])
                            ET.SubElement(cam, &#39;exposureUnits&#39;).text = self.exposure_units[isetup]
                            # end of new XML data
                            a = ET.SubElement(vs, &#39;attributes&#39;)
                            ET.SubElement(a, &#39;illumination&#39;).text = str(iillumination)
                            ET.SubElement(a, &#39;channel&#39;).text = str(ichannel)
                            ET.SubElement(a, &#39;tile&#39;).text = str(itile)
                            ET.SubElement(a, &#39;angle&#39;).text = str(iangle)

        # write Attributes (range of values)
        attrs_illum = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_illum.set(&#39;name&#39;, &#39;illumination&#39;)
        for iilumination in range(self.nilluminations):
            illum = ET.SubElement(attrs_illum, &#39;Illumination&#39;)
            ET.SubElement(illum, &#39;id&#39;).text = str(iilumination)
            ET.SubElement(illum, &#39;name&#39;).text = &#39;illumination &#39; + str(iilumination)

        attrs_chan = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_chan.set(&#39;name&#39;, &#39;channel&#39;)
        for ichannel in range(self.nchannels):
            chan = ET.SubElement(attrs_chan, &#39;Channel&#39;)
            ET.SubElement(chan, &#39;id&#39;).text = str(ichannel)
            ET.SubElement(chan, &#39;name&#39;).text = &#39;channel &#39; + str(ichannel)

        attrs_tile = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_tile.set(&#39;name&#39;, &#39;tile&#39;)
        for itile in range(self.ntiles):
            tile = ET.SubElement(attrs_tile, &#39;Tile&#39;)
            ET.SubElement(tile, &#39;id&#39;).text = str(itile)
            ET.SubElement(tile, &#39;name&#39;).text = &#39;tile &#39; + str(itile)

        attrs_ang = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_ang.set(&#39;name&#39;, &#39;angle&#39;)
        for iangle in range(self.nangles):
            ang = ET.SubElement(attrs_ang, &#39;Angle&#39;)
            ET.SubElement(ang, &#39;id&#39;).text = str(iangle)
            ET.SubElement(ang, &#39;name&#39;).text = &#39;angle &#39; + str(iangle)

        # Time points
        tpoints = ET.SubElement(seqdesc, &#39;Timepoints&#39;)
        tpoints.set(&#39;type&#39;, &#39;range&#39;)
        ET.SubElement(tpoints, &#39;first&#39;).text = str(0)
        ET.SubElement(tpoints, &#39;last&#39;).text = str(ntimes - 1)

        # missing views
        if any(True in l for l in self.setup_id_present):
            miss_views = ET.SubElement(seqdesc, &#39;MissingViews&#39;)
            for t in range(len(self.setup_id_present)):
                for i in range(len(self.setup_id_present[t])):
                    if not self.setup_id_present[t][i]:
                        miss_view = ET.SubElement(miss_views, &#39;MissingView&#39;)
                        miss_view.set(&#39;timepoint&#39;, str(t))
                        miss_view.set(&#39;setup&#39;, str(i))

        # Transformations of coordinate system
        vregs = ET.SubElement(root, &#39;ViewRegistrations&#39;)
        for itime in range(ntimes):
            for isetup in range(self.nsetups):
                if self.setup_id_present[itime][isetup]:
                    vreg = ET.SubElement(vregs, &#39;ViewRegistration&#39;)
                    vreg.set(&#39;timepoint&#39;, str(itime))
                    vreg.set(&#39;setup&#39;, str(isetup))
                    # write arbitrary affine transformation, specific for each view
                    if isetup in self.affine_matrices.keys():
                        vt = ET.SubElement(vreg, &#39;ViewTransform&#39;)
                        vt.set(&#39;type&#39;, &#39;affine&#39;)
                        ET.SubElement(vt, &#39;Name&#39;).text = self.affine_names[isetup]
                        n_prec = 6
                        mx_string = np.array2string(self.affine_matrices[isetup].flatten(), separator=&#39; &#39;,
                                                    precision=n_prec, floatmode=&#39;fixed&#39;,
                                                    max_line_width=(n_prec+6)*4)
                        ET.SubElement(vt, &#39;affine&#39;).text = mx_string[1:-1].strip()

                    # write registration transformation (calibration)
                    vt = ET.SubElement(vreg, &#39;ViewTransform&#39;)
                    vt.set(&#39;type&#39;, &#39;affine&#39;)
                    ET.SubElement(vt, &#39;Name&#39;).text = &#39;calibration&#39;
                    calx, caly, calz = self.calibrations[isetup]
                    ET.SubElement(vt, &#39;affine&#39;).text = \
                        &#39;{} 0.0 0.0 0.0 0.0 {} 0.0 0.0 0.0 0.0 {} 0.0&#39;.format(calx, caly, calz)

        _xml_indent(root)
        tree = ET.ElementTree(root)
        tree.write(os.path.splitext(self.filename)[0] + &#34;.xml&#34;, xml_declaration=True, encoding=&#39;utf-8&#39;, method=&#34;xml&#34;)

    def _determine_setup_id(self, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Takes the view attributes (illumination, channel, tile, angle) and converts them into unique setup_id.
        
        Parameters:
        -----------
            illumination: int
            channel: int)
            tile: int
            angle: int
            
        Returns:
        --------
            setup_id: int, &gt;=0 (first setup)
            &#34;&#34;&#34;
        setup_id_matrix = np.arange(self.nsetups)
        setup_id_matrix = setup_id_matrix.reshape((self.nilluminations, self.nchannels, self.ntiles, self.nangles))
        setup_id = setup_id_matrix[illumination, channel, tile, angle]
        return setup_id

    def _update_setup_id_present(self, isetup, itime):
        &#34;&#34;&#34;Update the lookup table (list of lists) for missing setups&#34;&#34;&#34;
        if len(self.setup_id_present) &lt;= itime:
            self.setup_id_present.append([False] * self.nsetups)
        self.setup_id_present[itime][isetup] = True

    def close(self):
        &#34;&#34;&#34;Save changes and close the H5 file.&#34;&#34;&#34;
        self.file_object.flush()
        self.file_object.close()


class BdvEditor:
    __version__ = &#34;2020.10&#34;

    def __init__(self, filename):
        &#34;&#34;&#34;
        Class for reading and editing existing H5/XML file pairs.
        Warning: Editing of H5/XML files occurs in-place, and there is currently no undo option. Use at your own risk.
        Todo: add an option to save results as new XML file.

        Parameters:
        -----------
            filename: string,
                Path to either .h5 or .xml file. The other file of the pair must be present
                in the same folder.
        &#34;&#34;&#34;
        self._fmt = &#39;t{:05d}/s{:02d}/{}&#39;
        if filename[-2:] == &#39;h5&#39;:
            self.filename_h5 = filename
            self.filename_xml = filename[:-2] + &#39;xml&#39;
        elif filename[-3:] == &#39;xml&#39;:
            self.filename_h5 = filename[:-3] + &#39;h5&#39;
            self.filename_xml = filename
        assert os.path.exists(self.filename_h5), f&#34;Error: {self.filename_h5} file not found&#34;
        assert os.path.exists(self.filename_xml), f&#34;Error: {self.filename_xml} file not found&#34;
        self._file_object_h5 = h5py.File(self.filename_h5, &#39;r+&#39;)
        self._root = None
        self.ntimes, self.nilluminations, self.nchannels, self.ntiles, self.nangles = self.get_attribute_count()
        self.nsetups = self.nilluminations * self.nchannels * self.ntiles * self.nangles

    def get_attribute_count(self):
        &#34;&#34;&#34; Get the number of view attributes: time points, illuminations, channels, tiles, angles, using the XML file.
        Returns:
        --------
        (ntimes, nilluminations, nchannels, ntiles, nangle)
         &#34;&#34;&#34;
        with open(self.filename_xml, &#39;r&#39;) as file:
            root = ET.parse(file).getroot()
            element = root.find(&#34;./SequenceDescription/Timepoints[@type=&#39;range&#39;]&#34;)
            nt = int(element.find(&#39;last&#39;).text) - int(element.find(&#39;first&#39;).text) + 1 if element else 0
            ni = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;illumination&#39;]/Illumination&#34;))
            nch = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;channel&#39;]/Channel&#34;))
            ntiles = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;tile&#39;]/Tile&#34;))
            nang = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;angle&#39;]/Angle&#34;))
        return nt, ni, nch, ntiles, nang

    def read_view(self, time=0, illumination=0, channel=0, tile=0, angle=0, ilevel=0):
        &#34;&#34;&#34;Read a view (stack) specified by its time, attributes, and downsampling level into numpy array (uint16).
        Todo: implement detection of missing views using XML file, return None.

        Parameters:
        -----------
            time: int
                Index of time point (default 0).
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            ilevel: int
                Level of subsampling, if available (default 0, no subsampling)

        Returns:
        --------
            dataset: numpy array (dim=3, dtype=uint16)&#34;&#34;&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        group_name = self._fmt.format(time, isetup, ilevel)
        if self._file_object_h5:
            dataset = self._file_object_h5[group_name][&#34;cells&#34;][()].astype(&#39;uint16&#39;)
            return dataset
        else:
            raise ValueError(&#39;File object is None&#39;)

    def crop_view(self, bbox_xyz=((1, -1), (1, -1), None), illumination=0, channel=0, tile=0, angle=0, ilevel=0):
        &#34;&#34;&#34;Crop a view in-place, both in H5 and XML files, for all time points.

        Parameters:
        -----------
            bbox_xyz: tuple of int
                Bounding box of the crop. Default `((1, -1), (2, -2), None)` crops to view[1:-1, 2:-2, :].
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            ilevel: int
                Level of subsampling, if available (default 0, no subsampling)
        &#34;&#34;&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        if self._file_object_h5:
            for time in range(self.ntimes):
                group_name = self._fmt.format(time, isetup, ilevel)
                view_dataset = self._file_object_h5[group_name][&#34;cells&#34;]
                view_arr = view_dataset[()]
                if bbox_xyz[0]:
                    view_arr = view_arr[:, :, slice(*bbox_xyz[0])]
                if bbox_xyz[1]:
                    view_arr = view_arr[:, slice(*bbox_xyz[1]), :]
                if bbox_xyz[2]:
                    view_arr = view_arr[slice(*bbox_xyz[2]), :, :]
                view_dataset.resize(view_arr.shape)
                view_dataset[:] = view_arr # Always use braces here! A common mistake to omit them.
                self._file_object_h5.flush()
        else:
            raise FileNotFoundError(self.filename_h5)
        # Edit the XML file as well.
        with open(self.filename_xml, &#39;r+&#39;) as file:
            self._get_xml_root()
            for elem in self._root.findall(&#34;./SequenceDescription/ViewSetups/ViewSetup&#34;):
                elem_id = elem.find(&#34;id&#34;)
                if int(elem_id.text) == isetup:
                    nz, ny, nx = tuple(view_arr.shape)
                    elem_size = elem.find(&#34;size&#34;)
                    elem_size.text = &#39;{} {} {}&#39;.format(nx, ny, nz)

    def _determine_setup_id(self, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Takes the view attributes (illumination, channel, tile, angle) and converts them into unique setup_id.

        Parameters:
        -----------
            illumination: int
            channel: int
            tile: int
            angle: int

        Returns:
        --------
            setup_id: int, &gt;=0 (first setup)
            &#34;&#34;&#34;
        setup_id_matrix = np.arange(self.nsetups)
        setup_id_matrix = setup_id_matrix.reshape((self.nilluminations, self.nchannels, self.ntiles, self.nangles))
        setup_id = setup_id_matrix[illumination, channel, tile, angle]
        return setup_id

    def get_view_property(self, key, illumination=0, channel=0, tile=0, angle=0) -&gt; tuple:
        &#34;&#34;&#34;&#34;Get property of a vew setup from XML file. No time information required, since the setups are fixed.
        Tuples are returned in (x, y, z) order, as in the XML file.
        Parameters:
        -----------
            key: str
                Name of the property: &#39;voxel_size&#39; | &#39;view_shape&#39;
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
        Returns:
        --------
            Value of the property, a tuple.
        &#34;&#34;&#34;
        accepted_keys = [&#39;voxel_size&#39;, &#39;view_shape&#39;]
        assert key in accepted_keys, f&#34;Key {key} not recognized, must be one of: {accepted_keys}.&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._get_xml_root()
        if key == &#39;voxel_size&#39;:
            path = &#34;./SequenceDescription/ViewSetups/ViewSetup/voxelSize/size&#34;
            type_caster = float
        elif key == &#39;view_shape&#39;:
            path = &#34;./SequenceDescription/ViewSetups/ViewSetup/size&#34;
            type_caster = int
        props_list = self._root.findall(path)
        # Todo: possible bug here, if the views are not in setupID order.
        assert 0 &lt;= isetup &lt; len(props_list), f&#34;Setup index {isetup} out of range 0..{len(props_list)-1}&#34;
        value = tuple([type_caster(val) for val in props_list[isetup].text.split()])
        return value

    def append_affine(self, m_affine, name_affine=&#34;Appended affine transformation using npy2bdv.&#34;,
                      time=0, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;&#34; Append affine transformation to a view. This transformation will be placed on top,
        e.g. executed by the BigStitcher last.
        The transformation is defined as matrix of shape (3,4).
        Each column represents coordinate unit vectors after the transformation.
        The last column represents translation in (x,y,z).

        Parameters:
        -----------
            time: int
                Time index, &gt;=0.
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            m_affine: numpy array of shape (3,4)
                Coefficients of affine transformation matrix (m00, m01, ...)
            name_affine: str, optional
                Name of the affine transformation.
            &#34;&#34;&#34;
        self._get_xml_root()
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        assert m_affine.shape == (3,4), &#34;m_affine must be a numpy array of shape (3,4)&#34;
        found = False
        for node in self._root.findall(&#39;./ViewRegistrations/ViewRegistration&#39;):
            if int(node.attrib[&#39;setup&#39;]) == isetup and int(node.attrib[&#39;timepoint&#39;]) == time:
                found = True
                break
        assert found, f&#39;Node not found: &lt;ViewRegistration setup=&#34;{isetup}&#34; timepoint=&#34;{time}&#34;&gt;&#39;
        vt = ET.Element(&#39;ViewTransform&#39;)
        node.insert(0, vt)
        vt.set(&#39;type&#39;, &#39;affine&#39;)
        ET.SubElement(vt, &#39;Name&#39;).text = name_affine
        n_prec = 6
        mx_string = np.array2string(m_affine.flatten(), separator=&#39; &#39;,
                                    precision=n_prec, floatmode=&#39;fixed&#39;,
                                    max_line_width=(n_prec + 6) * 4)
        ET.SubElement(vt, &#39;affine&#39;).text = mx_string[1:-1].strip()

    def _get_xml_root(self):
        &#34;&#34;&#34;Load the meta-information information from XML header file&#34;&#34;&#34;
        assert os.path.exists(self.filename_xml), f&#34;Error: {self.filename_xml} file not found&#34;
        if self._root is None:
            with open(self.filename_xml, &#39;r&#39;) as file:
                self._root = ET.parse(file).getroot()
        else:
            pass

    def finalize(self):
        &#34;&#34;&#34;Finalize the H5 and XML files: save changes and close them.&#34;&#34;&#34;
        if self._file_object_h5 is not None:
            self._file_object_h5.close()
        if self._root is not None:
            _xml_indent(self._root)
            tree = ET.ElementTree(self._root)
            shutil.copy(self.filename_xml, self.filename_xml + &#39;~1&#39;) # backup the previous XML file.
            tree.write(self.filename_xml, xml_declaration=True, encoding=&#39;utf-8&#39;, method=&#34;xml&#34;)


def _xml_indent(elem, level=0):
    &#34;&#34;&#34;Pretty printing function&#34;&#34;&#34;
    i = &#34;\n&#34; + level * &#34;  &#34;
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + &#34;  &#34;
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            _xml_indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="npy2bdv.npy2bdv.BdvEditor"><code class="flex name class">
<span>class <span class="ident">BdvEditor</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for reading and editing existing H5/XML file pairs.
Warning: Editing of H5/XML files occurs in-place, and there is currently no undo option. Use at your own risk.
Todo: add an option to save results as new XML file.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>filename: string,
    Path to either .h5 or .xml file. The other file of the pair must be present
    in the same folder.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BdvEditor:
    __version__ = &#34;2020.10&#34;

    def __init__(self, filename):
        &#34;&#34;&#34;
        Class for reading and editing existing H5/XML file pairs.
        Warning: Editing of H5/XML files occurs in-place, and there is currently no undo option. Use at your own risk.
        Todo: add an option to save results as new XML file.

        Parameters:
        -----------
            filename: string,
                Path to either .h5 or .xml file. The other file of the pair must be present
                in the same folder.
        &#34;&#34;&#34;
        self._fmt = &#39;t{:05d}/s{:02d}/{}&#39;
        if filename[-2:] == &#39;h5&#39;:
            self.filename_h5 = filename
            self.filename_xml = filename[:-2] + &#39;xml&#39;
        elif filename[-3:] == &#39;xml&#39;:
            self.filename_h5 = filename[:-3] + &#39;h5&#39;
            self.filename_xml = filename
        assert os.path.exists(self.filename_h5), f&#34;Error: {self.filename_h5} file not found&#34;
        assert os.path.exists(self.filename_xml), f&#34;Error: {self.filename_xml} file not found&#34;
        self._file_object_h5 = h5py.File(self.filename_h5, &#39;r+&#39;)
        self._root = None
        self.ntimes, self.nilluminations, self.nchannels, self.ntiles, self.nangles = self.get_attribute_count()
        self.nsetups = self.nilluminations * self.nchannels * self.ntiles * self.nangles

    def get_attribute_count(self):
        &#34;&#34;&#34; Get the number of view attributes: time points, illuminations, channels, tiles, angles, using the XML file.
        Returns:
        --------
        (ntimes, nilluminations, nchannels, ntiles, nangle)
         &#34;&#34;&#34;
        with open(self.filename_xml, &#39;r&#39;) as file:
            root = ET.parse(file).getroot()
            element = root.find(&#34;./SequenceDescription/Timepoints[@type=&#39;range&#39;]&#34;)
            nt = int(element.find(&#39;last&#39;).text) - int(element.find(&#39;first&#39;).text) + 1 if element else 0
            ni = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;illumination&#39;]/Illumination&#34;))
            nch = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;channel&#39;]/Channel&#34;))
            ntiles = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;tile&#39;]/Tile&#34;))
            nang = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;angle&#39;]/Angle&#34;))
        return nt, ni, nch, ntiles, nang

    def read_view(self, time=0, illumination=0, channel=0, tile=0, angle=0, ilevel=0):
        &#34;&#34;&#34;Read a view (stack) specified by its time, attributes, and downsampling level into numpy array (uint16).
        Todo: implement detection of missing views using XML file, return None.

        Parameters:
        -----------
            time: int
                Index of time point (default 0).
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            ilevel: int
                Level of subsampling, if available (default 0, no subsampling)

        Returns:
        --------
            dataset: numpy array (dim=3, dtype=uint16)&#34;&#34;&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        group_name = self._fmt.format(time, isetup, ilevel)
        if self._file_object_h5:
            dataset = self._file_object_h5[group_name][&#34;cells&#34;][()].astype(&#39;uint16&#39;)
            return dataset
        else:
            raise ValueError(&#39;File object is None&#39;)

    def crop_view(self, bbox_xyz=((1, -1), (1, -1), None), illumination=0, channel=0, tile=0, angle=0, ilevel=0):
        &#34;&#34;&#34;Crop a view in-place, both in H5 and XML files, for all time points.

        Parameters:
        -----------
            bbox_xyz: tuple of int
                Bounding box of the crop. Default `((1, -1), (2, -2), None)` crops to view[1:-1, 2:-2, :].
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            ilevel: int
                Level of subsampling, if available (default 0, no subsampling)
        &#34;&#34;&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        if self._file_object_h5:
            for time in range(self.ntimes):
                group_name = self._fmt.format(time, isetup, ilevel)
                view_dataset = self._file_object_h5[group_name][&#34;cells&#34;]
                view_arr = view_dataset[()]
                if bbox_xyz[0]:
                    view_arr = view_arr[:, :, slice(*bbox_xyz[0])]
                if bbox_xyz[1]:
                    view_arr = view_arr[:, slice(*bbox_xyz[1]), :]
                if bbox_xyz[2]:
                    view_arr = view_arr[slice(*bbox_xyz[2]), :, :]
                view_dataset.resize(view_arr.shape)
                view_dataset[:] = view_arr # Always use braces here! A common mistake to omit them.
                self._file_object_h5.flush()
        else:
            raise FileNotFoundError(self.filename_h5)
        # Edit the XML file as well.
        with open(self.filename_xml, &#39;r+&#39;) as file:
            self._get_xml_root()
            for elem in self._root.findall(&#34;./SequenceDescription/ViewSetups/ViewSetup&#34;):
                elem_id = elem.find(&#34;id&#34;)
                if int(elem_id.text) == isetup:
                    nz, ny, nx = tuple(view_arr.shape)
                    elem_size = elem.find(&#34;size&#34;)
                    elem_size.text = &#39;{} {} {}&#39;.format(nx, ny, nz)

    def _determine_setup_id(self, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Takes the view attributes (illumination, channel, tile, angle) and converts them into unique setup_id.

        Parameters:
        -----------
            illumination: int
            channel: int
            tile: int
            angle: int

        Returns:
        --------
            setup_id: int, &gt;=0 (first setup)
            &#34;&#34;&#34;
        setup_id_matrix = np.arange(self.nsetups)
        setup_id_matrix = setup_id_matrix.reshape((self.nilluminations, self.nchannels, self.ntiles, self.nangles))
        setup_id = setup_id_matrix[illumination, channel, tile, angle]
        return setup_id

    def get_view_property(self, key, illumination=0, channel=0, tile=0, angle=0) -&gt; tuple:
        &#34;&#34;&#34;&#34;Get property of a vew setup from XML file. No time information required, since the setups are fixed.
        Tuples are returned in (x, y, z) order, as in the XML file.
        Parameters:
        -----------
            key: str
                Name of the property: &#39;voxel_size&#39; | &#39;view_shape&#39;
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
        Returns:
        --------
            Value of the property, a tuple.
        &#34;&#34;&#34;
        accepted_keys = [&#39;voxel_size&#39;, &#39;view_shape&#39;]
        assert key in accepted_keys, f&#34;Key {key} not recognized, must be one of: {accepted_keys}.&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._get_xml_root()
        if key == &#39;voxel_size&#39;:
            path = &#34;./SequenceDescription/ViewSetups/ViewSetup/voxelSize/size&#34;
            type_caster = float
        elif key == &#39;view_shape&#39;:
            path = &#34;./SequenceDescription/ViewSetups/ViewSetup/size&#34;
            type_caster = int
        props_list = self._root.findall(path)
        # Todo: possible bug here, if the views are not in setupID order.
        assert 0 &lt;= isetup &lt; len(props_list), f&#34;Setup index {isetup} out of range 0..{len(props_list)-1}&#34;
        value = tuple([type_caster(val) for val in props_list[isetup].text.split()])
        return value

    def append_affine(self, m_affine, name_affine=&#34;Appended affine transformation using npy2bdv.&#34;,
                      time=0, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;&#34; Append affine transformation to a view. This transformation will be placed on top,
        e.g. executed by the BigStitcher last.
        The transformation is defined as matrix of shape (3,4).
        Each column represents coordinate unit vectors after the transformation.
        The last column represents translation in (x,y,z).

        Parameters:
        -----------
            time: int
                Time index, &gt;=0.
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            m_affine: numpy array of shape (3,4)
                Coefficients of affine transformation matrix (m00, m01, ...)
            name_affine: str, optional
                Name of the affine transformation.
            &#34;&#34;&#34;
        self._get_xml_root()
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        assert m_affine.shape == (3,4), &#34;m_affine must be a numpy array of shape (3,4)&#34;
        found = False
        for node in self._root.findall(&#39;./ViewRegistrations/ViewRegistration&#39;):
            if int(node.attrib[&#39;setup&#39;]) == isetup and int(node.attrib[&#39;timepoint&#39;]) == time:
                found = True
                break
        assert found, f&#39;Node not found: &lt;ViewRegistration setup=&#34;{isetup}&#34; timepoint=&#34;{time}&#34;&gt;&#39;
        vt = ET.Element(&#39;ViewTransform&#39;)
        node.insert(0, vt)
        vt.set(&#39;type&#39;, &#39;affine&#39;)
        ET.SubElement(vt, &#39;Name&#39;).text = name_affine
        n_prec = 6
        mx_string = np.array2string(m_affine.flatten(), separator=&#39; &#39;,
                                    precision=n_prec, floatmode=&#39;fixed&#39;,
                                    max_line_width=(n_prec + 6) * 4)
        ET.SubElement(vt, &#39;affine&#39;).text = mx_string[1:-1].strip()

    def _get_xml_root(self):
        &#34;&#34;&#34;Load the meta-information information from XML header file&#34;&#34;&#34;
        assert os.path.exists(self.filename_xml), f&#34;Error: {self.filename_xml} file not found&#34;
        if self._root is None:
            with open(self.filename_xml, &#39;r&#39;) as file:
                self._root = ET.parse(file).getroot()
        else:
            pass

    def finalize(self):
        &#34;&#34;&#34;Finalize the H5 and XML files: save changes and close them.&#34;&#34;&#34;
        if self._file_object_h5 is not None:
            self._file_object_h5.close()
        if self._root is not None:
            _xml_indent(self._root)
            tree = ET.ElementTree(self._root)
            shutil.copy(self.filename_xml, self.filename_xml + &#39;~1&#39;) # backup the previous XML file.
            tree.write(self.filename_xml, xml_declaration=True, encoding=&#39;utf-8&#39;, method=&#34;xml&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="npy2bdv.npy2bdv.BdvEditor.append_affine"><code class="name flex">
<span>def <span class="ident">append_affine</span></span>(<span>self, m_affine, name_affine='Appended affine transformation using npy2bdv.', time=0, illumination=0, channel=0, tile=0, angle=0)</span>
</code></dt>
<dd>
<div class="desc"><p>" Append affine transformation to a view. This transformation will be placed on top,
e.g. executed by the BigStitcher last.
The transformation is defined as matrix of shape (3,4).
Each column represents coordinate unit vectors after the transformation.
The last column represents translation in (x,y,z).</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>time: int
    Time index, &gt;=0.
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;= 0.
m_affine: numpy array of shape (3,4)
    Coefficients of affine transformation matrix (m00, m01, ...)
name_affine: str, optional
    Name of the affine transformation.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_affine(self, m_affine, name_affine=&#34;Appended affine transformation using npy2bdv.&#34;,
                  time=0, illumination=0, channel=0, tile=0, angle=0):
    &#34;&#34;&#34;&#34; Append affine transformation to a view. This transformation will be placed on top,
    e.g. executed by the BigStitcher last.
    The transformation is defined as matrix of shape (3,4).
    Each column represents coordinate unit vectors after the transformation.
    The last column represents translation in (x,y,z).

    Parameters:
    -----------
        time: int
            Time index, &gt;=0.
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;= 0.
        m_affine: numpy array of shape (3,4)
            Coefficients of affine transformation matrix (m00, m01, ...)
        name_affine: str, optional
            Name of the affine transformation.
        &#34;&#34;&#34;
    self._get_xml_root()
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    assert m_affine.shape == (3,4), &#34;m_affine must be a numpy array of shape (3,4)&#34;
    found = False
    for node in self._root.findall(&#39;./ViewRegistrations/ViewRegistration&#39;):
        if int(node.attrib[&#39;setup&#39;]) == isetup and int(node.attrib[&#39;timepoint&#39;]) == time:
            found = True
            break
    assert found, f&#39;Node not found: &lt;ViewRegistration setup=&#34;{isetup}&#34; timepoint=&#34;{time}&#34;&gt;&#39;
    vt = ET.Element(&#39;ViewTransform&#39;)
    node.insert(0, vt)
    vt.set(&#39;type&#39;, &#39;affine&#39;)
    ET.SubElement(vt, &#39;Name&#39;).text = name_affine
    n_prec = 6
    mx_string = np.array2string(m_affine.flatten(), separator=&#39; &#39;,
                                precision=n_prec, floatmode=&#39;fixed&#39;,
                                max_line_width=(n_prec + 6) * 4)
    ET.SubElement(vt, &#39;affine&#39;).text = mx_string[1:-1].strip()</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvEditor.crop_view"><code class="name flex">
<span>def <span class="ident">crop_view</span></span>(<span>self, bbox_xyz=((1, -1), (1, -1), None), illumination=0, channel=0, tile=0, angle=0, ilevel=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop a view in-place, both in H5 and XML files, for all time points.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>bbox_xyz: tuple of int
    Bounding box of the crop. Default `((1, -1), (2, -2), None)` crops to view[1:-1, 2:-2, :].
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;= 0.
ilevel: int
    Level of subsampling, if available (default 0, no subsampling)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_view(self, bbox_xyz=((1, -1), (1, -1), None), illumination=0, channel=0, tile=0, angle=0, ilevel=0):
    &#34;&#34;&#34;Crop a view in-place, both in H5 and XML files, for all time points.

    Parameters:
    -----------
        bbox_xyz: tuple of int
            Bounding box of the crop. Default `((1, -1), (2, -2), None)` crops to view[1:-1, 2:-2, :].
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;= 0.
        ilevel: int
            Level of subsampling, if available (default 0, no subsampling)
    &#34;&#34;&#34;
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    if self._file_object_h5:
        for time in range(self.ntimes):
            group_name = self._fmt.format(time, isetup, ilevel)
            view_dataset = self._file_object_h5[group_name][&#34;cells&#34;]
            view_arr = view_dataset[()]
            if bbox_xyz[0]:
                view_arr = view_arr[:, :, slice(*bbox_xyz[0])]
            if bbox_xyz[1]:
                view_arr = view_arr[:, slice(*bbox_xyz[1]), :]
            if bbox_xyz[2]:
                view_arr = view_arr[slice(*bbox_xyz[2]), :, :]
            view_dataset.resize(view_arr.shape)
            view_dataset[:] = view_arr # Always use braces here! A common mistake to omit them.
            self._file_object_h5.flush()
    else:
        raise FileNotFoundError(self.filename_h5)
    # Edit the XML file as well.
    with open(self.filename_xml, &#39;r+&#39;) as file:
        self._get_xml_root()
        for elem in self._root.findall(&#34;./SequenceDescription/ViewSetups/ViewSetup&#34;):
            elem_id = elem.find(&#34;id&#34;)
            if int(elem_id.text) == isetup:
                nz, ny, nx = tuple(view_arr.shape)
                elem_size = elem.find(&#34;size&#34;)
                elem_size.text = &#39;{} {} {}&#39;.format(nx, ny, nz)</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvEditor.finalize"><code class="name flex">
<span>def <span class="ident">finalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finalize the H5 and XML files: save changes and close them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize(self):
    &#34;&#34;&#34;Finalize the H5 and XML files: save changes and close them.&#34;&#34;&#34;
    if self._file_object_h5 is not None:
        self._file_object_h5.close()
    if self._root is not None:
        _xml_indent(self._root)
        tree = ET.ElementTree(self._root)
        shutil.copy(self.filename_xml, self.filename_xml + &#39;~1&#39;) # backup the previous XML file.
        tree.write(self.filename_xml, xml_declaration=True, encoding=&#39;utf-8&#39;, method=&#34;xml&#34;)</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvEditor.get_attribute_count"><code class="name flex">
<span>def <span class="ident">get_attribute_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the number of view attributes: time points, illuminations, channels, tiles, angles, using the XML file.
Returns:</p>
<hr>
<p>(ntimes, nilluminations, nchannels, ntiles, nangle)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribute_count(self):
    &#34;&#34;&#34; Get the number of view attributes: time points, illuminations, channels, tiles, angles, using the XML file.
    Returns:
    --------
    (ntimes, nilluminations, nchannels, ntiles, nangle)
     &#34;&#34;&#34;
    with open(self.filename_xml, &#39;r&#39;) as file:
        root = ET.parse(file).getroot()
        element = root.find(&#34;./SequenceDescription/Timepoints[@type=&#39;range&#39;]&#34;)
        nt = int(element.find(&#39;last&#39;).text) - int(element.find(&#39;first&#39;).text) + 1 if element else 0
        ni = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;illumination&#39;]/Illumination&#34;))
        nch = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;channel&#39;]/Channel&#34;))
        ntiles = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;tile&#39;]/Tile&#34;))
        nang = len(root.findall(&#34;./SequenceDescription/ViewSetups/Attributes[@name=&#39;angle&#39;]/Angle&#34;))
    return nt, ni, nch, ntiles, nang</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvEditor.get_view_property"><code class="name flex">
<span>def <span class="ident">get_view_property</span></span>(<span>self, key, illumination=0, channel=0, tile=0, angle=0) >tuple</span>
</code></dt>
<dd>
<div class="desc"><p>"Get property of a vew setup from XML file. No time information required, since the setups are fixed.
Tuples are returned in (x, y, z) order, as in the XML file.
Parameters:</p>
<hr>
<pre><code>key: str
    Name of the property: 'voxel_size' | 'view_shape'
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;= 0.
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>Value of the property, a tuple.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_view_property(self, key, illumination=0, channel=0, tile=0, angle=0) -&gt; tuple:
    &#34;&#34;&#34;&#34;Get property of a vew setup from XML file. No time information required, since the setups are fixed.
    Tuples are returned in (x, y, z) order, as in the XML file.
    Parameters:
    -----------
        key: str
            Name of the property: &#39;voxel_size&#39; | &#39;view_shape&#39;
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;= 0.
    Returns:
    --------
        Value of the property, a tuple.
    &#34;&#34;&#34;
    accepted_keys = [&#39;voxel_size&#39;, &#39;view_shape&#39;]
    assert key in accepted_keys, f&#34;Key {key} not recognized, must be one of: {accepted_keys}.&#34;
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    self._get_xml_root()
    if key == &#39;voxel_size&#39;:
        path = &#34;./SequenceDescription/ViewSetups/ViewSetup/voxelSize/size&#34;
        type_caster = float
    elif key == &#39;view_shape&#39;:
        path = &#34;./SequenceDescription/ViewSetups/ViewSetup/size&#34;
        type_caster = int
    props_list = self._root.findall(path)
    # Todo: possible bug here, if the views are not in setupID order.
    assert 0 &lt;= isetup &lt; len(props_list), f&#34;Setup index {isetup} out of range 0..{len(props_list)-1}&#34;
    value = tuple([type_caster(val) for val in props_list[isetup].text.split()])
    return value</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvEditor.read_view"><code class="name flex">
<span>def <span class="ident">read_view</span></span>(<span>self, time=0, illumination=0, channel=0, tile=0, angle=0, ilevel=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a view (stack) specified by its time, attributes, and downsampling level into numpy array (uint16).
Todo: implement detection of missing views using XML file, return None.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>time: int
    Index of time point (default 0).
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;= 0.
ilevel: int
    Level of subsampling, if available (default 0, no subsampling)
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>dataset: numpy array (dim=3, dtype=uint16)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_view(self, time=0, illumination=0, channel=0, tile=0, angle=0, ilevel=0):
    &#34;&#34;&#34;Read a view (stack) specified by its time, attributes, and downsampling level into numpy array (uint16).
    Todo: implement detection of missing views using XML file, return None.

    Parameters:
    -----------
        time: int
            Index of time point (default 0).
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;= 0.
        ilevel: int
            Level of subsampling, if available (default 0, no subsampling)

    Returns:
    --------
        dataset: numpy array (dim=3, dtype=uint16)&#34;&#34;&#34;
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    group_name = self._fmt.format(time, isetup, ilevel)
    if self._file_object_h5:
        dataset = self._file_object_h5[group_name][&#34;cells&#34;][()].astype(&#39;uint16&#39;)
        return dataset
    else:
        raise ValueError(&#39;File object is None&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="npy2bdv.npy2bdv.BdvWriter"><code class="flex name class">
<span>class <span class="ident">BdvWriter</span></span>
<span>(</span><span>filename, subsamp=((1, 1, 1),), blockdim=((4, 256, 256),), compression=None, nilluminations=1, nchannels=1, ntiles=1, nangles=1, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for writing multiple numpy 3d-arrays into BigDataViewer/BigStitcher HDF5 file.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>filename: string
    File name (full path).
subsamp: tuple of tuples
    Subsampling levels in (z,y,x) order. Integers &gt;= 1, default value ((1, 1, 1),) for no subsampling.
blockdim: tuple of tuples
    Block size for h5 storage, in pixels, in (z,y,x) order. Default ((4,256,256),), see notes.
compression: None or str
    (None, 'gzip', 'lzf'), HDF5 compression method. Default is None for high-speed writing.
nilluminations: int
nchannels: int
ntiles: int
nangles: int
    Number of view attributes, &gt;=1.
overwrite: boolean
    If True, overwrite existing file. Default False.
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
</div>
<hr>
<p>Input stacks and output files are assumed uint16 type.</p>
<p>The h5 recommended block (chunk) size should be between 10 KB and 1 MB, larger for large arrays.
For example, block dimensions (4,256,256)px gives ~0.5MB block size for type int16 (2 bytes) and writes very fast.
Block size can be larger than stack dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BdvWriter:
    __version__ = &#34;2020.10&#34;

    def __init__(self, filename,
                 subsamp=((1, 1, 1),),
                 blockdim=((4, 256, 256),),
                 compression=None,
                 nilluminations=1, nchannels=1, ntiles=1, nangles=1,
                 overwrite=False):
        &#34;&#34;&#34;Class for writing multiple numpy 3d-arrays into BigDataViewer/BigStitcher HDF5 file.

        Parameters:
        -----------
            filename: string
                File name (full path).
            subsamp: tuple of tuples
                Subsampling levels in (z,y,x) order. Integers &gt;= 1, default value ((1, 1, 1),) for no subsampling.
            blockdim: tuple of tuples
                Block size for h5 storage, in pixels, in (z,y,x) order. Default ((4,256,256),), see notes.
            compression: None or str
                (None, &#39;gzip&#39;, &#39;lzf&#39;), HDF5 compression method. Default is None for high-speed writing.
            nilluminations: int
            nchannels: int
            ntiles: int
            nangles: int
                Number of view attributes, &gt;=1.
            overwrite: boolean
                If True, overwrite existing file. Default False.

        .. note::
        ------
        Input stacks and output files are assumed uint16 type.

        The h5 recommended block (chunk) size should be between 10 KB and 1 MB, larger for large arrays.
        For example, block dimensions (4,256,256)px gives ~0.5MB block size for type int16 (2 bytes) and writes very fast.
        Block size can be larger than stack dimension.
        &#34;&#34;&#34;
        assert nilluminations &gt;= 1, &#34;Total number of illuminations must be at least 1.&#34;
        assert nchannels &gt;= 1, &#34;Total number of channels must be at least 1.&#34;
        assert ntiles &gt;= 1, &#34;Total number of tiles must be at least 1.&#34;
        assert nangles &gt;= 1, &#34;Total number of angles must be at least 1.&#34;
        assert compression in (None, &#39;gzip&#39;, &#39;lzf&#39;), &#39;Unknown compression type&#39;
        assert all([isinstance(element, int) for tupl in subsamp for element in
                    tupl]), &#39;subsamp values should be integers &gt;= 1.&#39;
        if len(blockdim) &lt; len(subsamp):
            print(f&#34;INFO: blockdim levels ({len(blockdim)}) &lt; subsamp levels ({len(subsamp)}):&#34;
                  f&#34; First-level block size {blockdim[0]} will be used for all levels&#34;)
        self._fmt = &#39;t{:05d}/s{:02d}/{}&#39;
        self.nsetups = nilluminations * nchannels * ntiles * nangles
        self.nilluminations = nilluminations
        self.nchannels = nchannels
        self.ntiles = ntiles
        self.nangles = nangles
        self.subsamp = np.asarray(subsamp)
        self.nlevels = len(subsamp)
        self.chunks = self._compute_chunk_size(blockdim)
        self.stack_shapes = {}
        self.affine_matrices = {}
        self.affine_names = {}
        self.calibrations = {}
        self.voxel_size_xyz = {}
        self.voxel_units = {}
        self.exposure_time = {}
        self.exposure_units = {}
        self.compression = compression
        self.filename = filename
        if os.path.exists(self.filename):
            if overwrite:
                os.remove(self.filename)
                print(&#34;Warning: H5 file already exists, overwriting.&#34;)
            else:
                raise FileExistsError(f&#34;File {self.filename} already exists.&#34;)
        self.file_object = h5py.File(filename, &#39;a&#39;)
        self._write_setups_header()
        self.virtual_stacks = False
        self.setup_id_present = [[False] * self.nsetups]

    def _write_setups_header(self):
        &#34;&#34;&#34;Write resolutions and subdivisions for all setups into h5 file.&#34;&#34;&#34;
        for isetup in range(self.nsetups):
            group_name = &#39;s{:02d}&#39;.format(isetup)
            if group_name in self.file_object:
                del self.file_object[group_name]
            grp = self.file_object.create_group(group_name)
            data_subsamp = np.flip(self.subsamp, 1)
            data_chunks = np.flip(self.chunks, 1)
            grp.create_dataset(&#39;resolutions&#39;, data=data_subsamp, dtype=&#39;&lt;f8&#39;)
            grp.create_dataset(&#39;subdivisions&#39;, data=data_chunks, dtype=&#39;&lt;i4&#39;)

    def append_plane(self, plane, z, time=0, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Append a plane to a virtual stack. Requires stack initialization by calling e.g.
        `append_view(stack=None, virtual_stack_dim=(1000,2048,2048))` beforehand.
        
        Parameters:
        -----------
            plane: array_like
                A 2d numpy array of (y,x) pixel values.
            z: int
                Plane z-position in the virtual stack.
            time: int
                Time index of the view, &gt;=0.
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;=0.
        &#34;&#34;&#34;
        
        assert self.virtual_stacks, &#34;Appending planes requires initialization with virtual stack, &#34; \
                                    &#34;see append_view(stack=None,...)&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._update_setup_id_present(isetup, time)
        assert plane.shape == self.stack_shapes[isetup][1:], &#34;Plane dimensions must match (y,x) size of virtual stack.&#34;
        assert z &lt; self.stack_shapes[isetup][0], &#34;Plane index must be less than virtual stack z-dimension.&#34;
        for ilevel in range(self.nlevels):
            group_name = self._fmt.format(time, isetup, ilevel)
            dataset = self.file_object[group_name][&#34;cells&#34;]
            dataset[z, :, :] = self._subsample_plane(plane, self.subsamp[ilevel]).astype(&#39;int16&#39;)

    def append_substack(self, substack, z_start, y_start=0, x_start=0,
                        time=0, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Append a substack to a virtual stack. Requires stack initialization by calling e.g.
        `append_view(stack=None, virtual_stack_dim=(1000,2048,2048))` beforehand.

        Parameters:
        -----------
            substack: array_like
                A 3d numpy array of (z,y,x) pixel values.
            z_start: int
            y_start: int
            z_start: int
                Offsets (z,y,x) of the substack in the virtual stack.
            time: int
                Time index of the view, &gt;=0.
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;=0.
        &#34;&#34;&#34;

        assert self.virtual_stacks, &#34;Appending substack requires initialization with virtual stack, &#34; \
                                    &#34;see append_view(stack=None,...)&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._update_setup_id_present(isetup, time)
        assert z_start + substack.shape[0] &lt;= self.stack_shapes[isetup][0], \
            f&#34;Substack offset {z_start} + z-dim {substack.shape[0]} &gt; virtual stack z-dim {self.stack_shapes[isetup][0]}.&#34;
        assert y_start + substack.shape[1] &lt;= self.stack_shapes[isetup][1], \
            f&#34;Substack offset {y_start} + y-dim {substack.shape[1]} &gt; virtual stack y-dim {self.stack_shapes[isetup][1]}.&#34;
        assert x_start + substack.shape[2] &lt;= self.stack_shapes[isetup][2], \
            f&#34;Substack offset {x_start} + x-dim {substack.shape[2]} &gt; virtual stack x-dim {self.stack_shapes[isetup][2]}.&#34;
        for ilevel in range(self.nlevels):
            group_name = self._fmt.format(time, isetup, ilevel)
            dataset = self.file_object[group_name][&#34;cells&#34;]
            subdata = self._subsample_stack(substack, self.subsamp[ilevel]).astype(&#39;int16&#39;)
            dataset[z_start : z_start + substack.shape[0],
                    y_start : y_start + substack.shape[1],
                    x_start : x_start + substack.shape[2]] = subdata

    def append_view(self, stack, virtual_stack_dim=None,
                    time=0, illumination=0, channel=0, tile=0, angle=0,
                    m_affine=None, name_affine=&#39;manually defined&#39;,
                    voxel_size_xyz=(1, 1, 1), voxel_units=&#39;px&#39;, calibration=(1, 1, 1),
                    exposure_time=0, exposure_units=&#39;s&#39;):
        &#34;&#34;&#34;
        Write 3-dimensional numpy array (stack) to the h5 file with the specified timepoint `itime` and attributes.
        
        Parameters:
        -----------
            stack: numpy array (uint16) or None
                A 3-dimensional stack of uint16 data in (z,y,x) axis order.
                If None, creates an empty dataset of size huge_stack_dim.
            virtual_stack_dim: None, or tuple of (z,y,x) dimensions, optional.
                Dimensions to allocate a huge stack and fill it later by individual planes or substacks.
            time: int
            illumination: int
            channel: int
            tile: int
            angle: int
                Indices of the view attributes, &gt;= 0.
            m_affine: a numpy array of shape (3,4), optional.
                Coefficients of affine transformation matrix (m00, m01, ...). The last column is translation in (x,y,z).
            name_affine: str, optional
                Name of the affine transformation.
            voxel_size_xyz: tuple of size 3, optional
                The physical size of voxel, in voxel_units. Default (1, 1, 1).
            voxel_units: str, optional
                Spatial units, default is &#39;px&#39;.
            calibration: tuple of size 3, optional
                The anisotropy factors for (x,y,z) voxel calibration. Default (1, 1, 1).
                Leave it default unless you know how it affects transformations.
            exposure_time: float, optional
                Camera exposure time for this view, default 0.
            exposure_units: str, optional
                Time units for this view, default &#34;s&#34;.
        &#34;&#34;&#34;
        
        assert len(calibration) == 3, &#34;Calibration must be a tuple of 3 elements (x, y, z).&#34;
        assert len(voxel_size_xyz) == 3, &#34;Voxel size must be a tuple of 3 elements (x, y, z).&#34;
        isetup = self._determine_setup_id(illumination, channel, tile, angle)
        self._update_setup_id_present(isetup, time)
        if stack is not None:
            assert len(stack.shape) == 3, &#34;Stack should be a 3-dimensional numpy array (z,y,x)&#34;
            self.stack_shapes[isetup] = stack.shape
        else:
            assert len(virtual_stack_dim) == 3, &#34;Stack is virtual, so parameter virtual_stack_dim must be defined.&#34;
            self.stack_shapes[isetup] = virtual_stack_dim
            self.virtual_stacks = True

        for ilevel in range(self.nlevels):
            group_name = self._fmt.format(time, isetup, ilevel)
            if group_name in self.file_object:
                del self.file_object[group_name]
            grp = self.file_object.create_group(group_name)
            if stack is not None:
                subdata = self._subsample_stack(stack, self.subsamp[ilevel]).astype(&#39;int16&#39;)
                grp.create_dataset(&#39;cells&#39;, data=subdata, chunks=self.chunks[ilevel],
                                   maxshape=(None, None, None), compression=self.compression, dtype=&#39;int16&#39;)
            else:  # a virtual stack initialized
                grp.create_dataset(&#39;cells&#39;, chunks=self.chunks[ilevel],
                                   shape=virtual_stack_dim // self.subsamp[ilevel],
                                   compression=self.compression, dtype=&#39;int16&#39;)
        if m_affine is not None:
            self.affine_matrices[isetup] = m_affine.copy()
            self.affine_names[isetup] = name_affine
        self.calibrations[isetup] = calibration
        self.voxel_size_xyz[isetup] = voxel_size_xyz
        self.voxel_units[isetup] = voxel_units
        self.exposure_time[isetup] = exposure_time
        self.exposure_units[isetup] = exposure_units

    def _compute_chunk_size(self, blockdim):
        &#34;&#34;&#34;Populate the size of h5 chunks.
        Use first-level chunk size if there are more subsampling levels than chunk size levels.
        &#34;&#34;&#34;
        chunks = []
        base_level = blockdim[0]
        if len(blockdim) &lt; len(self.subsamp):
            for ilevel in range(len(self.subsamp)):
                chunks.append(base_level)
            chunks_tuple = tuple(chunks)
        else:
            chunks_tuple = blockdim
        return chunks_tuple

    def _subsample_stack(self, stack, subsamp_level):
        &#34;&#34;&#34;Subsampling of 3d stack.
        
        Parameters:
        -----------
            stack, numpy 3d array (z,y,x) of int16
            subsamp_level, array-like with 3 elements, eg (2,4,4) for downsampling z(x2), x and y (x4).
            
        Returns:
        --------
            down-scaled stack, unit16 type.
        &#34;&#34;&#34;
        if all(subsamp_level[:] == 1):
            stack_sub = stack
        else:
            stack_sub = skimage.transform.downscale_local_mean(stack, tuple(subsamp_level)).astype(np.uint16)
        return stack_sub

    def _subsample_plane(self, plane, subsamp_level):
        &#34;&#34;&#34;Subsampling of a 2d plane.
        
        Parameters:
        -----------
            plane: numpy 2d array (y,x) of int16
            subsamp_level: array-like with 3 elements, eg (1,4,4) for downsampling x and y (x4).
            
        Returns:
        --------
            down-scaled plane, unit16 type.
        &#34;&#34;&#34;
        assert subsamp_level[0] == 1, &#34;z-subsampling must be == 1 for virtual stacks.&#34;
        if all(subsamp_level[:] == 1):
            plane_sub = plane
        else:
            plane_sub = skimage.transform.downscale_local_mean(plane, tuple(subsamp_level[1:])).astype(np.uint16)
        return plane_sub

    def write_xml_file(self, ntimes=1,
                       camera_name=&#34;default&#34;,  microscope_name=&#34;default&#34;,
                       microscope_version=&#34;0.0&#34;, user_name=&#34;user&#34;):
        &#34;&#34;&#34;
        Write XML header file for the HDF5 file.

        Parameters:
        -----------
            ntimes: int
                Number of time points
            camera_name: str, optional
                Name of the camera (same for all setups at the moment)
            microscope_name: str, optional
            microscope_version: str, optional
            user_name: str, optional
        &#34;&#34;&#34;
        assert ntimes &gt;= 1, &#34;Total number of time points must be at least 1.&#34;
        root = ET.Element(&#39;SpimData&#39;)
        root.set(&#39;version&#39;, &#39;0.2&#39;)
        bp = ET.SubElement(root, &#39;BasePath&#39;)
        bp.set(&#39;type&#39;, &#39;relative&#39;)
        bp.text = &#39;.&#39;
        # new XML data, added by @nvladimus
        generator = ET.SubElement(root, &#39;generatedBy&#39;)
        library = ET.SubElement(generator, &#39;library&#39;)
        library.set(&#39;version&#39;, self.__version__)
        library.text = &#34;npy2bdv&#34;
        microscope = ET.SubElement(generator, &#39;microscope&#39;)
        ET.SubElement(microscope, &#39;name&#39;).text = microscope_name
        ET.SubElement(microscope, &#39;version&#39;).text = microscope_version
        ET.SubElement(microscope, &#39;user&#39;).text = user_name
        # end of new XML data

        seqdesc = ET.SubElement(root, &#39;SequenceDescription&#39;)
        imgload = ET.SubElement(seqdesc, &#39;ImageLoader&#39;)
        imgload.set(&#39;format&#39;, &#39;bdv.hdf5&#39;)
        el = ET.SubElement(imgload, &#39;hdf5&#39;)
        el.set(&#39;type&#39;, &#39;relative&#39;)
        el.text = os.path.basename(self.filename)
        # write ViewSetups
        viewsets = ET.SubElement(seqdesc, &#39;ViewSetups&#39;)
        for iillumination in range(self.nilluminations):
            for ichannel in range(self.nchannels):
                for itile in range(self.ntiles):
                    for iangle in range(self.nangles):
                        isetup = self._determine_setup_id(iillumination, ichannel, itile, iangle)
                        if any([self.setup_id_present[t][isetup] for t in range(len(self.setup_id_present))]):
                            vs = ET.SubElement(viewsets, &#39;ViewSetup&#39;)
                            ET.SubElement(vs, &#39;id&#39;).text = str(isetup)
                            ET.SubElement(vs, &#39;name&#39;).text = &#39;setup &#39; + str(isetup)
                            nz, ny, nx = tuple(self.stack_shapes[isetup])
                            ET.SubElement(vs, &#39;size&#39;).text = &#39;{} {} {}&#39;.format(nx, ny, nz)
                            vox = ET.SubElement(vs, &#39;voxelSize&#39;)
                            ET.SubElement(vox, &#39;unit&#39;).text = self.voxel_units[isetup]
                            dx, dy, dz = self.voxel_size_xyz[isetup]
                            ET.SubElement(vox, &#39;size&#39;).text = &#39;{} {} {}&#39;.format(dx, dy, dz)
                            # new XML data, added by @nvladimus
                            cam = ET.SubElement(vs, &#39;camera&#39;)
                            ET.SubElement(cam, &#39;name&#39;).text = camera_name
                            ET.SubElement(cam, &#39;exposureTime&#39;).text = &#39;{}&#39;.format(self.exposure_time[isetup])
                            ET.SubElement(cam, &#39;exposureUnits&#39;).text = self.exposure_units[isetup]
                            # end of new XML data
                            a = ET.SubElement(vs, &#39;attributes&#39;)
                            ET.SubElement(a, &#39;illumination&#39;).text = str(iillumination)
                            ET.SubElement(a, &#39;channel&#39;).text = str(ichannel)
                            ET.SubElement(a, &#39;tile&#39;).text = str(itile)
                            ET.SubElement(a, &#39;angle&#39;).text = str(iangle)

        # write Attributes (range of values)
        attrs_illum = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_illum.set(&#39;name&#39;, &#39;illumination&#39;)
        for iilumination in range(self.nilluminations):
            illum = ET.SubElement(attrs_illum, &#39;Illumination&#39;)
            ET.SubElement(illum, &#39;id&#39;).text = str(iilumination)
            ET.SubElement(illum, &#39;name&#39;).text = &#39;illumination &#39; + str(iilumination)

        attrs_chan = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_chan.set(&#39;name&#39;, &#39;channel&#39;)
        for ichannel in range(self.nchannels):
            chan = ET.SubElement(attrs_chan, &#39;Channel&#39;)
            ET.SubElement(chan, &#39;id&#39;).text = str(ichannel)
            ET.SubElement(chan, &#39;name&#39;).text = &#39;channel &#39; + str(ichannel)

        attrs_tile = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_tile.set(&#39;name&#39;, &#39;tile&#39;)
        for itile in range(self.ntiles):
            tile = ET.SubElement(attrs_tile, &#39;Tile&#39;)
            ET.SubElement(tile, &#39;id&#39;).text = str(itile)
            ET.SubElement(tile, &#39;name&#39;).text = &#39;tile &#39; + str(itile)

        attrs_ang = ET.SubElement(viewsets, &#39;Attributes&#39;)
        attrs_ang.set(&#39;name&#39;, &#39;angle&#39;)
        for iangle in range(self.nangles):
            ang = ET.SubElement(attrs_ang, &#39;Angle&#39;)
            ET.SubElement(ang, &#39;id&#39;).text = str(iangle)
            ET.SubElement(ang, &#39;name&#39;).text = &#39;angle &#39; + str(iangle)

        # Time points
        tpoints = ET.SubElement(seqdesc, &#39;Timepoints&#39;)
        tpoints.set(&#39;type&#39;, &#39;range&#39;)
        ET.SubElement(tpoints, &#39;first&#39;).text = str(0)
        ET.SubElement(tpoints, &#39;last&#39;).text = str(ntimes - 1)

        # missing views
        if any(True in l for l in self.setup_id_present):
            miss_views = ET.SubElement(seqdesc, &#39;MissingViews&#39;)
            for t in range(len(self.setup_id_present)):
                for i in range(len(self.setup_id_present[t])):
                    if not self.setup_id_present[t][i]:
                        miss_view = ET.SubElement(miss_views, &#39;MissingView&#39;)
                        miss_view.set(&#39;timepoint&#39;, str(t))
                        miss_view.set(&#39;setup&#39;, str(i))

        # Transformations of coordinate system
        vregs = ET.SubElement(root, &#39;ViewRegistrations&#39;)
        for itime in range(ntimes):
            for isetup in range(self.nsetups):
                if self.setup_id_present[itime][isetup]:
                    vreg = ET.SubElement(vregs, &#39;ViewRegistration&#39;)
                    vreg.set(&#39;timepoint&#39;, str(itime))
                    vreg.set(&#39;setup&#39;, str(isetup))
                    # write arbitrary affine transformation, specific for each view
                    if isetup in self.affine_matrices.keys():
                        vt = ET.SubElement(vreg, &#39;ViewTransform&#39;)
                        vt.set(&#39;type&#39;, &#39;affine&#39;)
                        ET.SubElement(vt, &#39;Name&#39;).text = self.affine_names[isetup]
                        n_prec = 6
                        mx_string = np.array2string(self.affine_matrices[isetup].flatten(), separator=&#39; &#39;,
                                                    precision=n_prec, floatmode=&#39;fixed&#39;,
                                                    max_line_width=(n_prec+6)*4)
                        ET.SubElement(vt, &#39;affine&#39;).text = mx_string[1:-1].strip()

                    # write registration transformation (calibration)
                    vt = ET.SubElement(vreg, &#39;ViewTransform&#39;)
                    vt.set(&#39;type&#39;, &#39;affine&#39;)
                    ET.SubElement(vt, &#39;Name&#39;).text = &#39;calibration&#39;
                    calx, caly, calz = self.calibrations[isetup]
                    ET.SubElement(vt, &#39;affine&#39;).text = \
                        &#39;{} 0.0 0.0 0.0 0.0 {} 0.0 0.0 0.0 0.0 {} 0.0&#39;.format(calx, caly, calz)

        _xml_indent(root)
        tree = ET.ElementTree(root)
        tree.write(os.path.splitext(self.filename)[0] + &#34;.xml&#34;, xml_declaration=True, encoding=&#39;utf-8&#39;, method=&#34;xml&#34;)

    def _determine_setup_id(self, illumination=0, channel=0, tile=0, angle=0):
        &#34;&#34;&#34;Takes the view attributes (illumination, channel, tile, angle) and converts them into unique setup_id.
        
        Parameters:
        -----------
            illumination: int
            channel: int)
            tile: int
            angle: int
            
        Returns:
        --------
            setup_id: int, &gt;=0 (first setup)
            &#34;&#34;&#34;
        setup_id_matrix = np.arange(self.nsetups)
        setup_id_matrix = setup_id_matrix.reshape((self.nilluminations, self.nchannels, self.ntiles, self.nangles))
        setup_id = setup_id_matrix[illumination, channel, tile, angle]
        return setup_id

    def _update_setup_id_present(self, isetup, itime):
        &#34;&#34;&#34;Update the lookup table (list of lists) for missing setups&#34;&#34;&#34;
        if len(self.setup_id_present) &lt;= itime:
            self.setup_id_present.append([False] * self.nsetups)
        self.setup_id_present[itime][isetup] = True

    def close(self):
        &#34;&#34;&#34;Save changes and close the H5 file.&#34;&#34;&#34;
        self.file_object.flush()
        self.file_object.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="npy2bdv.npy2bdv.BdvWriter.append_plane"><code class="name flex">
<span>def <span class="ident">append_plane</span></span>(<span>self, plane, z, time=0, illumination=0, channel=0, tile=0, angle=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a plane to a virtual stack. Requires stack initialization by calling e.g.
<code>append_view(stack=None, virtual_stack_dim=(1000,2048,2048))</code> beforehand.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>plane: array_like
    A 2d numpy array of (y,x) pixel values.
z: int
    Plane z-position in the virtual stack.
time: int
    Time index of the view, &gt;=0.
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;=0.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_plane(self, plane, z, time=0, illumination=0, channel=0, tile=0, angle=0):
    &#34;&#34;&#34;Append a plane to a virtual stack. Requires stack initialization by calling e.g.
    `append_view(stack=None, virtual_stack_dim=(1000,2048,2048))` beforehand.
    
    Parameters:
    -----------
        plane: array_like
            A 2d numpy array of (y,x) pixel values.
        z: int
            Plane z-position in the virtual stack.
        time: int
            Time index of the view, &gt;=0.
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;=0.
    &#34;&#34;&#34;
    
    assert self.virtual_stacks, &#34;Appending planes requires initialization with virtual stack, &#34; \
                                &#34;see append_view(stack=None,...)&#34;
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    self._update_setup_id_present(isetup, time)
    assert plane.shape == self.stack_shapes[isetup][1:], &#34;Plane dimensions must match (y,x) size of virtual stack.&#34;
    assert z &lt; self.stack_shapes[isetup][0], &#34;Plane index must be less than virtual stack z-dimension.&#34;
    for ilevel in range(self.nlevels):
        group_name = self._fmt.format(time, isetup, ilevel)
        dataset = self.file_object[group_name][&#34;cells&#34;]
        dataset[z, :, :] = self._subsample_plane(plane, self.subsamp[ilevel]).astype(&#39;int16&#39;)</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvWriter.append_substack"><code class="name flex">
<span>def <span class="ident">append_substack</span></span>(<span>self, substack, z_start, y_start=0, x_start=0, time=0, illumination=0, channel=0, tile=0, angle=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a substack to a virtual stack. Requires stack initialization by calling e.g.
<code>append_view(stack=None, virtual_stack_dim=(1000,2048,2048))</code> beforehand.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>substack: array_like
    A 3d numpy array of (z,y,x) pixel values.
z_start: int
y_start: int
z_start: int
    Offsets (z,y,x) of the substack in the virtual stack.
time: int
    Time index of the view, &gt;=0.
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;=0.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_substack(self, substack, z_start, y_start=0, x_start=0,
                    time=0, illumination=0, channel=0, tile=0, angle=0):
    &#34;&#34;&#34;Append a substack to a virtual stack. Requires stack initialization by calling e.g.
    `append_view(stack=None, virtual_stack_dim=(1000,2048,2048))` beforehand.

    Parameters:
    -----------
        substack: array_like
            A 3d numpy array of (z,y,x) pixel values.
        z_start: int
        y_start: int
        z_start: int
            Offsets (z,y,x) of the substack in the virtual stack.
        time: int
            Time index of the view, &gt;=0.
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;=0.
    &#34;&#34;&#34;

    assert self.virtual_stacks, &#34;Appending substack requires initialization with virtual stack, &#34; \
                                &#34;see append_view(stack=None,...)&#34;
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    self._update_setup_id_present(isetup, time)
    assert z_start + substack.shape[0] &lt;= self.stack_shapes[isetup][0], \
        f&#34;Substack offset {z_start} + z-dim {substack.shape[0]} &gt; virtual stack z-dim {self.stack_shapes[isetup][0]}.&#34;
    assert y_start + substack.shape[1] &lt;= self.stack_shapes[isetup][1], \
        f&#34;Substack offset {y_start} + y-dim {substack.shape[1]} &gt; virtual stack y-dim {self.stack_shapes[isetup][1]}.&#34;
    assert x_start + substack.shape[2] &lt;= self.stack_shapes[isetup][2], \
        f&#34;Substack offset {x_start} + x-dim {substack.shape[2]} &gt; virtual stack x-dim {self.stack_shapes[isetup][2]}.&#34;
    for ilevel in range(self.nlevels):
        group_name = self._fmt.format(time, isetup, ilevel)
        dataset = self.file_object[group_name][&#34;cells&#34;]
        subdata = self._subsample_stack(substack, self.subsamp[ilevel]).astype(&#39;int16&#39;)
        dataset[z_start : z_start + substack.shape[0],
                y_start : y_start + substack.shape[1],
                x_start : x_start + substack.shape[2]] = subdata</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvWriter.append_view"><code class="name flex">
<span>def <span class="ident">append_view</span></span>(<span>self, stack, virtual_stack_dim=None, time=0, illumination=0, channel=0, tile=0, angle=0, m_affine=None, name_affine='manually defined', voxel_size_xyz=(1, 1, 1), voxel_units='px', calibration=(1, 1, 1), exposure_time=0, exposure_units='s')</span>
</code></dt>
<dd>
<div class="desc"><p>Write 3-dimensional numpy array (stack) to the h5 file with the specified timepoint <code>itime</code> and attributes.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>stack: numpy array (uint16) or None
    A 3-dimensional stack of uint16 data in (z,y,x) axis order.
    If None, creates an empty dataset of size huge_stack_dim.
virtual_stack_dim: None, or tuple of (z,y,x) dimensions, optional.
    Dimensions to allocate a huge stack and fill it later by individual planes or substacks.
time: int
illumination: int
channel: int
tile: int
angle: int
    Indices of the view attributes, &gt;= 0.
m_affine: a numpy array of shape (3,4), optional.
    Coefficients of affine transformation matrix (m00, m01, ...). The last column is translation in (x,y,z).
name_affine: str, optional
    Name of the affine transformation.
voxel_size_xyz: tuple of size 3, optional
    The physical size of voxel, in voxel_units. Default (1, 1, 1).
voxel_units: str, optional
    Spatial units, default is 'px'.
calibration: tuple of size 3, optional
    The anisotropy factors for (x,y,z) voxel calibration. Default (1, 1, 1).
    Leave it default unless you know how it affects transformations.
exposure_time: float, optional
    Camera exposure time for this view, default 0.
exposure_units: str, optional
    Time units for this view, default "s".
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_view(self, stack, virtual_stack_dim=None,
                time=0, illumination=0, channel=0, tile=0, angle=0,
                m_affine=None, name_affine=&#39;manually defined&#39;,
                voxel_size_xyz=(1, 1, 1), voxel_units=&#39;px&#39;, calibration=(1, 1, 1),
                exposure_time=0, exposure_units=&#39;s&#39;):
    &#34;&#34;&#34;
    Write 3-dimensional numpy array (stack) to the h5 file with the specified timepoint `itime` and attributes.
    
    Parameters:
    -----------
        stack: numpy array (uint16) or None
            A 3-dimensional stack of uint16 data in (z,y,x) axis order.
            If None, creates an empty dataset of size huge_stack_dim.
        virtual_stack_dim: None, or tuple of (z,y,x) dimensions, optional.
            Dimensions to allocate a huge stack and fill it later by individual planes or substacks.
        time: int
        illumination: int
        channel: int
        tile: int
        angle: int
            Indices of the view attributes, &gt;= 0.
        m_affine: a numpy array of shape (3,4), optional.
            Coefficients of affine transformation matrix (m00, m01, ...). The last column is translation in (x,y,z).
        name_affine: str, optional
            Name of the affine transformation.
        voxel_size_xyz: tuple of size 3, optional
            The physical size of voxel, in voxel_units. Default (1, 1, 1).
        voxel_units: str, optional
            Spatial units, default is &#39;px&#39;.
        calibration: tuple of size 3, optional
            The anisotropy factors for (x,y,z) voxel calibration. Default (1, 1, 1).
            Leave it default unless you know how it affects transformations.
        exposure_time: float, optional
            Camera exposure time for this view, default 0.
        exposure_units: str, optional
            Time units for this view, default &#34;s&#34;.
    &#34;&#34;&#34;
    
    assert len(calibration) == 3, &#34;Calibration must be a tuple of 3 elements (x, y, z).&#34;
    assert len(voxel_size_xyz) == 3, &#34;Voxel size must be a tuple of 3 elements (x, y, z).&#34;
    isetup = self._determine_setup_id(illumination, channel, tile, angle)
    self._update_setup_id_present(isetup, time)
    if stack is not None:
        assert len(stack.shape) == 3, &#34;Stack should be a 3-dimensional numpy array (z,y,x)&#34;
        self.stack_shapes[isetup] = stack.shape
    else:
        assert len(virtual_stack_dim) == 3, &#34;Stack is virtual, so parameter virtual_stack_dim must be defined.&#34;
        self.stack_shapes[isetup] = virtual_stack_dim
        self.virtual_stacks = True

    for ilevel in range(self.nlevels):
        group_name = self._fmt.format(time, isetup, ilevel)
        if group_name in self.file_object:
            del self.file_object[group_name]
        grp = self.file_object.create_group(group_name)
        if stack is not None:
            subdata = self._subsample_stack(stack, self.subsamp[ilevel]).astype(&#39;int16&#39;)
            grp.create_dataset(&#39;cells&#39;, data=subdata, chunks=self.chunks[ilevel],
                               maxshape=(None, None, None), compression=self.compression, dtype=&#39;int16&#39;)
        else:  # a virtual stack initialized
            grp.create_dataset(&#39;cells&#39;, chunks=self.chunks[ilevel],
                               shape=virtual_stack_dim // self.subsamp[ilevel],
                               compression=self.compression, dtype=&#39;int16&#39;)
    if m_affine is not None:
        self.affine_matrices[isetup] = m_affine.copy()
        self.affine_names[isetup] = name_affine
    self.calibrations[isetup] = calibration
    self.voxel_size_xyz[isetup] = voxel_size_xyz
    self.voxel_units[isetup] = voxel_units
    self.exposure_time[isetup] = exposure_time
    self.exposure_units[isetup] = exposure_units</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvWriter.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save changes and close the H5 file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Save changes and close the H5 file.&#34;&#34;&#34;
    self.file_object.flush()
    self.file_object.close()</code></pre>
</details>
</dd>
<dt id="npy2bdv.npy2bdv.BdvWriter.write_xml_file"><code class="name flex">
<span>def <span class="ident">write_xml_file</span></span>(<span>self, ntimes=1, camera_name='default', microscope_name='default', microscope_version='0.0', user_name='user')</span>
</code></dt>
<dd>
<div class="desc"><p>Write XML header file for the HDF5 file.</p>
<h2 id="parameters">Parameters:</h2>
<pre><code>ntimes: int
    Number of time points
camera_name: str, optional
    Name of the camera (same for all setups at the moment)
microscope_name: str, optional
microscope_version: str, optional
user_name: str, optional
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_xml_file(self, ntimes=1,
                   camera_name=&#34;default&#34;,  microscope_name=&#34;default&#34;,
                   microscope_version=&#34;0.0&#34;, user_name=&#34;user&#34;):
    &#34;&#34;&#34;
    Write XML header file for the HDF5 file.

    Parameters:
    -----------
        ntimes: int
            Number of time points
        camera_name: str, optional
            Name of the camera (same for all setups at the moment)
        microscope_name: str, optional
        microscope_version: str, optional
        user_name: str, optional
    &#34;&#34;&#34;
    assert ntimes &gt;= 1, &#34;Total number of time points must be at least 1.&#34;
    root = ET.Element(&#39;SpimData&#39;)
    root.set(&#39;version&#39;, &#39;0.2&#39;)
    bp = ET.SubElement(root, &#39;BasePath&#39;)
    bp.set(&#39;type&#39;, &#39;relative&#39;)
    bp.text = &#39;.&#39;
    # new XML data, added by @nvladimus
    generator = ET.SubElement(root, &#39;generatedBy&#39;)
    library = ET.SubElement(generator, &#39;library&#39;)
    library.set(&#39;version&#39;, self.__version__)
    library.text = &#34;npy2bdv&#34;
    microscope = ET.SubElement(generator, &#39;microscope&#39;)
    ET.SubElement(microscope, &#39;name&#39;).text = microscope_name
    ET.SubElement(microscope, &#39;version&#39;).text = microscope_version
    ET.SubElement(microscope, &#39;user&#39;).text = user_name
    # end of new XML data

    seqdesc = ET.SubElement(root, &#39;SequenceDescription&#39;)
    imgload = ET.SubElement(seqdesc, &#39;ImageLoader&#39;)
    imgload.set(&#39;format&#39;, &#39;bdv.hdf5&#39;)
    el = ET.SubElement(imgload, &#39;hdf5&#39;)
    el.set(&#39;type&#39;, &#39;relative&#39;)
    el.text = os.path.basename(self.filename)
    # write ViewSetups
    viewsets = ET.SubElement(seqdesc, &#39;ViewSetups&#39;)
    for iillumination in range(self.nilluminations):
        for ichannel in range(self.nchannels):
            for itile in range(self.ntiles):
                for iangle in range(self.nangles):
                    isetup = self._determine_setup_id(iillumination, ichannel, itile, iangle)
                    if any([self.setup_id_present[t][isetup] for t in range(len(self.setup_id_present))]):
                        vs = ET.SubElement(viewsets, &#39;ViewSetup&#39;)
                        ET.SubElement(vs, &#39;id&#39;).text = str(isetup)
                        ET.SubElement(vs, &#39;name&#39;).text = &#39;setup &#39; + str(isetup)
                        nz, ny, nx = tuple(self.stack_shapes[isetup])
                        ET.SubElement(vs, &#39;size&#39;).text = &#39;{} {} {}&#39;.format(nx, ny, nz)
                        vox = ET.SubElement(vs, &#39;voxelSize&#39;)
                        ET.SubElement(vox, &#39;unit&#39;).text = self.voxel_units[isetup]
                        dx, dy, dz = self.voxel_size_xyz[isetup]
                        ET.SubElement(vox, &#39;size&#39;).text = &#39;{} {} {}&#39;.format(dx, dy, dz)
                        # new XML data, added by @nvladimus
                        cam = ET.SubElement(vs, &#39;camera&#39;)
                        ET.SubElement(cam, &#39;name&#39;).text = camera_name
                        ET.SubElement(cam, &#39;exposureTime&#39;).text = &#39;{}&#39;.format(self.exposure_time[isetup])
                        ET.SubElement(cam, &#39;exposureUnits&#39;).text = self.exposure_units[isetup]
                        # end of new XML data
                        a = ET.SubElement(vs, &#39;attributes&#39;)
                        ET.SubElement(a, &#39;illumination&#39;).text = str(iillumination)
                        ET.SubElement(a, &#39;channel&#39;).text = str(ichannel)
                        ET.SubElement(a, &#39;tile&#39;).text = str(itile)
                        ET.SubElement(a, &#39;angle&#39;).text = str(iangle)

    # write Attributes (range of values)
    attrs_illum = ET.SubElement(viewsets, &#39;Attributes&#39;)
    attrs_illum.set(&#39;name&#39;, &#39;illumination&#39;)
    for iilumination in range(self.nilluminations):
        illum = ET.SubElement(attrs_illum, &#39;Illumination&#39;)
        ET.SubElement(illum, &#39;id&#39;).text = str(iilumination)
        ET.SubElement(illum, &#39;name&#39;).text = &#39;illumination &#39; + str(iilumination)

    attrs_chan = ET.SubElement(viewsets, &#39;Attributes&#39;)
    attrs_chan.set(&#39;name&#39;, &#39;channel&#39;)
    for ichannel in range(self.nchannels):
        chan = ET.SubElement(attrs_chan, &#39;Channel&#39;)
        ET.SubElement(chan, &#39;id&#39;).text = str(ichannel)
        ET.SubElement(chan, &#39;name&#39;).text = &#39;channel &#39; + str(ichannel)

    attrs_tile = ET.SubElement(viewsets, &#39;Attributes&#39;)
    attrs_tile.set(&#39;name&#39;, &#39;tile&#39;)
    for itile in range(self.ntiles):
        tile = ET.SubElement(attrs_tile, &#39;Tile&#39;)
        ET.SubElement(tile, &#39;id&#39;).text = str(itile)
        ET.SubElement(tile, &#39;name&#39;).text = &#39;tile &#39; + str(itile)

    attrs_ang = ET.SubElement(viewsets, &#39;Attributes&#39;)
    attrs_ang.set(&#39;name&#39;, &#39;angle&#39;)
    for iangle in range(self.nangles):
        ang = ET.SubElement(attrs_ang, &#39;Angle&#39;)
        ET.SubElement(ang, &#39;id&#39;).text = str(iangle)
        ET.SubElement(ang, &#39;name&#39;).text = &#39;angle &#39; + str(iangle)

    # Time points
    tpoints = ET.SubElement(seqdesc, &#39;Timepoints&#39;)
    tpoints.set(&#39;type&#39;, &#39;range&#39;)
    ET.SubElement(tpoints, &#39;first&#39;).text = str(0)
    ET.SubElement(tpoints, &#39;last&#39;).text = str(ntimes - 1)

    # missing views
    if any(True in l for l in self.setup_id_present):
        miss_views = ET.SubElement(seqdesc, &#39;MissingViews&#39;)
        for t in range(len(self.setup_id_present)):
            for i in range(len(self.setup_id_present[t])):
                if not self.setup_id_present[t][i]:
                    miss_view = ET.SubElement(miss_views, &#39;MissingView&#39;)
                    miss_view.set(&#39;timepoint&#39;, str(t))
                    miss_view.set(&#39;setup&#39;, str(i))

    # Transformations of coordinate system
    vregs = ET.SubElement(root, &#39;ViewRegistrations&#39;)
    for itime in range(ntimes):
        for isetup in range(self.nsetups):
            if self.setup_id_present[itime][isetup]:
                vreg = ET.SubElement(vregs, &#39;ViewRegistration&#39;)
                vreg.set(&#39;timepoint&#39;, str(itime))
                vreg.set(&#39;setup&#39;, str(isetup))
                # write arbitrary affine transformation, specific for each view
                if isetup in self.affine_matrices.keys():
                    vt = ET.SubElement(vreg, &#39;ViewTransform&#39;)
                    vt.set(&#39;type&#39;, &#39;affine&#39;)
                    ET.SubElement(vt, &#39;Name&#39;).text = self.affine_names[isetup]
                    n_prec = 6
                    mx_string = np.array2string(self.affine_matrices[isetup].flatten(), separator=&#39; &#39;,
                                                precision=n_prec, floatmode=&#39;fixed&#39;,
                                                max_line_width=(n_prec+6)*4)
                    ET.SubElement(vt, &#39;affine&#39;).text = mx_string[1:-1].strip()

                # write registration transformation (calibration)
                vt = ET.SubElement(vreg, &#39;ViewTransform&#39;)
                vt.set(&#39;type&#39;, &#39;affine&#39;)
                ET.SubElement(vt, &#39;Name&#39;).text = &#39;calibration&#39;
                calx, caly, calz = self.calibrations[isetup]
                ET.SubElement(vt, &#39;affine&#39;).text = \
                    &#39;{} 0.0 0.0 0.0 0.0 {} 0.0 0.0 0.0 0.0 {} 0.0&#39;.format(calx, caly, calz)

    _xml_indent(root)
    tree = ET.ElementTree(root)
    tree.write(os.path.splitext(self.filename)[0] + &#34;.xml&#34;, xml_declaration=True, encoding=&#39;utf-8&#39;, method=&#34;xml&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="npy2bdv" href="index.html">npy2bdv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="npy2bdv.npy2bdv.BdvEditor" href="#npy2bdv.npy2bdv.BdvEditor">BdvEditor</a></code></h4>
<ul class="two-column">
<li><code><a title="npy2bdv.npy2bdv.BdvEditor.append_affine" href="#npy2bdv.npy2bdv.BdvEditor.append_affine">append_affine</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvEditor.crop_view" href="#npy2bdv.npy2bdv.BdvEditor.crop_view">crop_view</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvEditor.finalize" href="#npy2bdv.npy2bdv.BdvEditor.finalize">finalize</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvEditor.get_attribute_count" href="#npy2bdv.npy2bdv.BdvEditor.get_attribute_count">get_attribute_count</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvEditor.get_view_property" href="#npy2bdv.npy2bdv.BdvEditor.get_view_property">get_view_property</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvEditor.read_view" href="#npy2bdv.npy2bdv.BdvEditor.read_view">read_view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="npy2bdv.npy2bdv.BdvWriter" href="#npy2bdv.npy2bdv.BdvWriter">BdvWriter</a></code></h4>
<ul class="">
<li><code><a title="npy2bdv.npy2bdv.BdvWriter.append_plane" href="#npy2bdv.npy2bdv.BdvWriter.append_plane">append_plane</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvWriter.append_substack" href="#npy2bdv.npy2bdv.BdvWriter.append_substack">append_substack</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvWriter.append_view" href="#npy2bdv.npy2bdv.BdvWriter.append_view">append_view</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvWriter.close" href="#npy2bdv.npy2bdv.BdvWriter.close">close</a></code></li>
<li><code><a title="npy2bdv.npy2bdv.BdvWriter.write_xml_file" href="#npy2bdv.npy2bdv.BdvWriter.write_xml_file">write_xml_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>